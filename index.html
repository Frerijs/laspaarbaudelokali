<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8">
  <title>LAS + CSV salīdzināšana (kdbush kā funkcija)</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #results table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }
    #results th,
    #results td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    #error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>LAS un CSV salīdzināšana (ar kdbush funkciju)</h1>
  <p>
    Ielādējiet <strong>LAS</strong> failu (EPSG:3059, <em>Point Data Format</em> 0..3) un
    <strong>CSV</strong> failu (x,y,z). Tiks izveidots kd-bush indekss, lai ātrāk meklētu
    tuvākos LAS punktus 20&nbsp;cm rādiusā.
  </p>

  <p>LAS fails:</p>
  <input type="file" id="lasFile" accept=".las" />

  <p>CSV fails:</p>
  <input type="file" id="csvFile" accept=".csv,text/csv" />

  <br>
  <button id="processBtn">Sākt apstrādi</button>

  <div id="error"></div>
  <div id="results"></div>

  <!-- Papa Parse CSV parsēšanai -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- kdbush UMD fails: window.kdbush ir FUNKCIJA, nevis klase -->
  <script src="https://cdn.jsdelivr.net/npm/kdbush@3.0.0/kdbush.umd.js"></script>

  <script>
    const errorDiv = document.getElementById('error');
    const resultsDiv = document.getElementById('results');
    const lasFileInput = document.getElementById('lasFile');
    const csvFileInput = document.getElementById('csvFile');
    const processBtn = document.getElementById('processBtn');

    // kdbush funkcija
    const kdbushFn = window.kdbush;

    let lasPoints = [];
    let csvPoints = [];
    let kdbIndex = null;

    // =============================================
    // 1) Vienkāršs LAS parseris (formāts 0..3)
    // =============================================
    async function parseLAS(file) {
      const buffer = await file.arrayBuffer();
      const dv = new DataView(buffer);

      // "LASF" signatūra
      const signature = String.fromCharCode(
        dv.getUint8(0),
        dv.getUint8(1),
        dv.getUint8(2),
        dv.getUint8(3)
      );
      if (signature !== "LASF") {
        throw new Error("Failam trūkst 'LASF' signatūra. Vai tas ir .las fails?");
      }

      const pointDataOffset = dv.getUint32(96, true);
      const numPoints = dv.getUint32(107, true);

      const scaleX = dv.getFloat64(131, true);
      const scaleY = dv.getFloat64(139, true);
      const scaleZ = dv.getFloat64(147, true);
      const offsetX = dv.getFloat64(155, true);
      const offsetY = dv.getFloat64(163, true);
      const offsetZ = dv.getFloat64(171, true);

      const pointDataFormat = dv.getUint8(104);
      const pointRecordLen = dv.getUint16(105, true);

      if (![0,1,2,3].includes(pointDataFormat)) {
        throw new Error("Neparedzēts Point Data Format: " + pointDataFormat);
      }

      const pointsArr = [];
      let off = pointDataOffset;
      for (let i = 0; i < numPoints; i++) {
        const Xint = dv.getInt32(off + 0, true);
        const Yint = dv.getInt32(off + 4, true);
        const Zint = dv.getInt32(off + 8, true);

        const X = Xint * scaleX + offsetX;
        const Y = Yint * scaleY + offsetY;
        const Z = Zint * scaleZ + offsetZ;

        pointsArr.push({x: X, y: Y, z: Z});
        off += pointRecordLen;
      }

      return pointsArr;
    }

    // =============================================
    // 2) CSV parsēšana ar PapaParse -> {x,y,z}
    // =============================================
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const arr = results.data;
              const points = arr.map(row => {
                const keys = {};
                for (let k of Object.keys(row)) {
                  keys[k.toLowerCase()] = row[k];
                }
                const X = parseFloat(keys['x']);
                const Y = parseFloat(keys['y']);
                const Z = parseFloat(keys['z']);
                return {x: X, y: Y, z: Z};
              }).filter(p => !isNaN(p.x) && !isNaN(p.y) && !isNaN(p.z));
              resolve(points);
            } catch (err) {
              reject(err);
            }
          },
          error: (err) => reject(err)
        });
      });
    }

    // =============================================
    // 3) Izveido k-d tree ar kdbush (funkciju)
    // =============================================
    function buildKDBushIndex(points) {
      return kdbushFn(
        points,
        p => p.x, // x accessor
        p => p.y, // y accessor
        64,
        Float32Array
      );
    }

    // =============================================
    // 4) Meklē tuvāko LAS punktu 20cm rādiusā
    //    izmantojot index.range() + manuālu dist
    // =============================================
    function findNearestLASPointKD(csvPt, radius = 0.2) {
      const minX = csvPt.x - radius;
      const minY = csvPt.y - radius;
      const maxX = csvPt.x + radius;
      const maxY = csvPt.y + radius;

      const candidateIndices = kdbIndex.range(minX, minY, maxX, maxY);
      let nearest = null;
      let minDist = Infinity;

      for (const idx of candidateIndices) {
        const lasPt = lasPoints[idx];
        const dx = lasPt.x - csvPt.x;
        const dy = lasPt.y - csvPt.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDist && dist <= radius) {
          minDist = dist;
          nearest = lasPt;
        }
      }
      return nearest;
    }

    // =============================================
    // 5) Process poga
    // =============================================
    processBtn.addEventListener('click', async () => {
      errorDiv.textContent = "";
      resultsDiv.innerHTML = "";

      if (!lasFileInput.files.length || !csvFileInput.files.length) {
        errorDiv.textContent = "Lūdzu, atlasiet gan LAS, gan CSV failu!";
        return;
      }

      try {
        resultsDiv.innerHTML = "<p>Ielādē un sagatavo datus, lūdzu uzgaidiet...</p>";

        // 1) LasPoints
        lasPoints = await parseLAS(lasFileInput.files[0]);

        // 2) Izveido k-d index
        kdbIndex = buildKDBushIndex(lasPoints);

        // 3) CSV punkti
        csvPoints = await parseCSV(csvFileInput.files[0]);

        // 4) Meklē tuvāko
        const tableRows = [];
        tableRows.push("<tr><th>CSV X</th><th>CSV Y</th><th>CSV Z</th><th>LAS Z</th><th>ΔZ (CSV-LAS)</th><th>2D dist</th></tr>");
        
        for (const cpt of csvPoints) {
          const nearest = findNearestLASPointKD(cpt, 0.2);
          if (nearest) {
            const dz = cpt.z - nearest.z;
            const dist2D = Math.sqrt((nearest.x - cpt.x)**2 + (nearest.y - cpt.y)**2);
            tableRows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>${nearest.z.toFixed(3)}</td>
                <td>${dz.toFixed(3)}</td>
                <td>${dist2D.toFixed(3)}</td>
              </tr>
            `);
          } else {
            tableRows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            `);
          }
        }

        resultsDiv.innerHTML = `
          <h3>Rezultāti</h3>
          <p>LAS punkti: ${lasPoints.length}, CSV punkti: ${csvPoints.length}</p>
          <table>${tableRows.join("")}</table>
        `;
      } catch (err) {
        console.error(err);
        errorDiv.textContent = err.message;
      }
    });
  </script>
</body>
</html>
