<script>
    async function processFiles() {
        let csvFile = document.getElementById("csvFile").files[0];

        if (!csvFile) {
            document.getElementById("output").innerText = "Lūdzu, augšupielādējiet CSV failu!";
            return;
        }

        let reader = new FileReader();
        reader.onload = async function(event) {
            let csvData = event.target.result;
            let pyodide = await loadPyodide();
            await pyodide.loadPackage(["numpy", "pandas", "scipy"]);

            let code = `
import pandas as pd
import numpy as np
from scipy.spatial import cKDTree
from io import StringIO

csv_df = pd.read_csv(StringIO(\"\"\"${csvData}\"\"\"))
csv_points = csv_df[['x', 'y', 'z']].to_numpy()

# Simulēti LAS punkti (jo Pyodide neatbalsta LAS failus tiešā veidā)
las_points = np.random.rand(len(csv_points), 3) * 100

# KDTree tuvāko punktu meklēšanai
tree = cKDTree(las_points[:, :2])
distances, indices = tree.query(csv_points[:, :2], distance_upper_bound=${maxDistance})

# Novērš IndexError, pārbaudot indeksu derīgumu
indices[indices >= len(las_points)] = -1

# Aprēķina Z atšķirību tikai derīgiem indeksiem
valid_mask = indices != -1
csv_df["Z_Difference"] = np.nan
csv_df.loc[valid_mask, "Z_Difference"] = csv_points[valid_mask, 2] - las_points[indices[valid_mask], 2]

csv_df.to_csv(index=False)
            `;

            let result = await pyodide.runPythonAsync(code);
            document.getElementById("output").innerText = "Rezultāti sagatavoti. Lejupielādējiet CSV.";
            downloadCsv(result);
        };
        reader.readAsText(csvFile);
    }
</script>
