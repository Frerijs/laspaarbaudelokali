<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8" />
  <title>LAS + CSV (Chunk + Parallel) ar rezultātu lejupielādi</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #results table { border-collapse: collapse; width:100%; margin-top:1rem; }
    #results th, #results td { border:1px solid #ccc; padding:6px 10px; text-align:left; }
    #error { color:red; font-weight:bold; }
  </style>
</head>
<body>
  <h1>LAS un CSV salīdzināšana: Chunk + Web Workers + CSV Lejupielāde</h1>

  <p><strong>LAS fails (EPSG:3059):</strong></p>
  <input type="file" id="lasFile" accept=".las" />

  <p><strong>CSV fails (EPSG:3059, kolonnas x,y,z):</strong></p>
  <input type="file" id="csvFile" accept=".csv,text/csv" />

  <br/>
  <button id="processBtn">Sākt apstrādi</button>

  <div id="error"></div>
  <div id="status"></div>
  <div id="results"></div>

  <!-- PapaParse CSV parsēšanai -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    /*************************************************************
     * GALVENAIS SCRIPTS
     *************************************************************/
    const lasInput = document.getElementById("lasFile");
    const csvInput = document.getElementById("csvFile");
    const processBtn = document.getElementById("processBtn");
    const errorDiv = document.getElementById("error");
    const statusDiv = document.getElementById("status");
    const resultsDiv = document.getElementById("results");

    // CSV punkti un labākās atbilstības
    let csvPoints = [];
    let bestDist = [];
    let bestLASZ = [];

    // Web Worker pool
    let workers = [];
    let freeWorkers = [];
    let chunkTasks = [];
    let totalChunks = 0;
    let chunksCompleted = 0;

    const CHUNK_SIZE = 100000;
    const MAX_DISTANCE = 0.2;
    let numWorkers = navigator.hardwareConcurrency || 4;

    let lasFile;
    let lasInfo;

    /*************************************************************
     * 1) CSV lasīšana
     *************************************************************/
    async function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const data = results.data;
              const pts = data.map(row => {
                const keys = {};
                for (let k of Object.keys(row)) {
                  keys[k.toLowerCase()] = row[k];
                }
                const X = parseFloat(keys['x']);
                const Y = parseFloat(keys['y']);
                const Z = parseFloat(keys['z']);
                return {x:X, y:Y, z:Z};
              }).filter(p=>!isNaN(p.x) && !isNaN(p.y) && !isNaN(p.z));
              resolve(pts);
            } catch (err) {
              reject(err);
            }
          },
          error: err => reject(err)
        });
      });
    }

    /*************************************************************
     * 2) LAS galvenes lasīšana
     *************************************************************/
    async function readLASHeader(file) {
      const headerSize = 375;
      const ab = await file.slice(0, headerSize).arrayBuffer();
      const dv = new DataView(ab);

      const signature = String.fromCharCode(
        dv.getUint8(0), dv.getUint8(1),
        dv.getUint8(2), dv.getUint8(3)
      );
      if (signature !== "LASF") {
        throw new Error("Failā nav 'LASF' signatūra");
      }

      const pointDataOffset = dv.getUint32(96, true);
      const numPoints = dv.getUint32(107, true);

      const scaleX = dv.getFloat64(131, true);
      const scaleY = dv.getFloat64(139, true);
      const scaleZ = dv.getFloat64(147, true);
      const offX = dv.getFloat64(155, true);
      const offY = dv.getFloat64(163, true);
      const offZ = dv.getFloat64(171, true);

      const fmt = dv.getUint8(104);
      if (![0,1,2,3].includes(fmt)) {
        throw new Error("Neparedzēts Point Data Format: "+fmt);
      }
      const recLen = dv.getUint16(105, true);

      return {
        numPoints,
        pointDataOffset,
        pointRecordLen: recLen,
        scale: [scaleX, scaleY, scaleZ],
        offset: [offX, offY, offZ]
      };
    }

    /*************************************************************
     * 3) Worker pool
     *************************************************************/
    function createWorkerPool(num) {
      workers = [];
      freeWorkers = [];
      for (let i=0; i<num; i++) {
        const blob = new Blob([document.getElementById('worker-script').textContent], {type:'application/javascript'});
        const url = URL.createObjectURL(blob);
        const w = new Worker(url);

        w.onmessage = (evt) => handleWorkerMessage(w, evt.data);
        workers.push(w);
        freeWorkers.push(w);
      }
    }

    function handleWorkerMessage(worker, msg) {
      if (msg.type === 'chunkResult') {
        // Saliekam starprezultātus
        for (const upd of msg.payload) {
          if (upd.dist < bestDist[upd.idx]) {
            bestDist[upd.idx] = upd.dist;
            bestLASZ[upd.idx] = upd.lasZ;
          }
        }
        chunksCompleted++;
        statusDiv.textContent = `Chunki pabeigti: ${chunksCompleted} / ${totalChunks}`;
        freeWorkers.push(worker);
        scheduleChunk();
      }
      else if (msg.type === 'done') {
        // Worker pabeidz
      }
      else if (msg.type === 'log') {
        console.log("Worker:", msg.payload);
      }
    }

    /*************************************************************
     * 4) Chunk scheduling
     *************************************************************/
    async function scheduleChunk() {
      if (chunkTasks.length===0) {
        if (chunksCompleted===totalChunks) {
          finalizeResults();
        }
        return;
      }
      if (freeWorkers.length===0) {
        return;
      }
      const task = chunkTasks.shift();
      const worker = freeWorkers.pop();

      const blob = lasFile.slice(task.byteStart, task.byteStart + task.byteLength);
      const arrayBuf = await blob.arrayBuffer();

      worker.postMessage({
        type:'processChunk',
        buffer: arrayBuf,
        chunkPoints: task.chunkPoints,
        pointRecordLen: lasInfo.pointRecordLen,
        scale: lasInfo.scale,
        offset: lasInfo.offset,
        maxDistance: MAX_DISTANCE
      }, [arrayBuf]);
    }

    /*************************************************************
     * 5) finalizeResults + CSV Lejupielādes daļa
     *************************************************************/
    function finalizeResults() {
      statusDiv.textContent = "Veido rezultātu...";
      // HTML tabula
      let html = `<table>
        <tr><th>CSV X</th><th>CSV Y</th><th>CSV Z</th><th>LAS Z</th><th>ΔZ</th><th>dist</th></tr>`;
      // CSV teksta rindas
      let csvLines = ["CSV_X,CSV_Y,CSV_Z,LAS_Z,DeltaZ,Dist"];

      for (let i=0; i<csvPoints.length; i++) {
        if (bestDist[i] < Infinity) {
          const dz = csvPoints[i].z - bestLASZ[i];
          html += `
            <tr>
              <td>${csvPoints[i].x.toFixed(3)}</td>
              <td>${csvPoints[i].y.toFixed(3)}</td>
              <td>${csvPoints[i].z.toFixed(3)}</td>
              <td>${bestLASZ[i].toFixed(3)}</td>
              <td>${dz.toFixed(3)}</td>
              <td>${bestDist[i].toFixed(3)}</td>
            </tr>
          `;
          // CSV rinda
          csvLines.push([
            csvPoints[i].x.toFixed(3),
            csvPoints[i].y.toFixed(3),
            csvPoints[i].z.toFixed(3),
            bestLASZ[i].toFixed(3),
            dz.toFixed(3),
            bestDist[i].toFixed(3)
          ].join(","));
        } else {
          html += `
            <tr>
              <td>${csvPoints[i].x.toFixed(3)}</td>
              <td>${csvPoints[i].y.toFixed(3)}</td>
              <td>${csvPoints[i].z.toFixed(3)}</td>
              <td>-</td><td>-</td><td>-</td>
            </tr>`;
          // CSV rinda: ar tukšiem lauciņiem
          csvLines.push([
            csvPoints[i].x.toFixed(3),
            csvPoints[i].y.toFixed(3),
            csvPoints[i].z.toFixed(3),
            "", "", ""
          ].join(","));
        }
      }
      html += "</table>";
      resultsDiv.innerHTML = `<h3>Rezultāts</h3>${html}`;

      // Tagad ģenerējam CSV failu
      const csvContent = csvLines.join("\n");
      const blob = new Blob([csvContent], {type: "text/csv"});
      const url = URL.createObjectURL(blob);

      // Pievienojam <a> linku lejupielādei
      const downloadLink = document.createElement("a");
      downloadLink.href = url;
      downloadLink.download = "rezultati.csv";
      downloadLink.textContent = "Lejupielādēt CSV";
      downloadLink.style.display = "inline-block";
      downloadLink.style.marginTop = "10px";

      resultsDiv.appendChild(document.createElement("br"));
      resultsDiv.appendChild(downloadLink);
    }

    /*************************************************************
     * 6) Pogas notikums
     *************************************************************/
    processBtn.addEventListener('click', async () => {
      errorDiv.textContent = "";
      resultsDiv.innerHTML = "";
      statusDiv.textContent = "";

      if (!csvInput.files.length || !lasInput.files.length) {
        errorDiv.textContent = "Lūdzu, atlasiet gan LAS, gan CSV failu!";
        return;
      }

      try {
        // 1) Nolasa CSV
        statusDiv.textContent = "Nolasa CSV...";
        csvPoints = await parseCSV(csvInput.files[0]);
        bestDist = new Array(csvPoints.length).fill(Infinity);
        bestLASZ = new Array(csvPoints.length).fill(null);

        // 2) Nolasa LAS galveni
        statusDiv.textContent = "Nolasa LAS galveni...";
        lasFile = lasInput.files[0];
        lasInfo = await readLASHeader(lasFile);

        // 3) sagatavo chunk
        chunkTasks = [];
        let pointsRemaining = lasInfo.numPoints;
        let currentByteOffset = lasInfo.pointDataOffset;
        let totalPointsRead = 0;

        while (pointsRemaining>0) {
          const chunkPoints = Math.min(CHUNK_SIZE, pointsRemaining);
          const byteLen = chunkPoints * lasInfo.pointRecordLen;
          chunkTasks.push({
            chunkPoints,
            byteStart: currentByteOffset,
            byteLength: byteLen
          });
          currentByteOffset += byteLen;
          pointsRemaining -= chunkPoints;
          totalPointsRead += chunkPoints;
        }
        totalChunks = chunkTasks.length;
        chunksCompleted = 0;
        statusDiv.textContent = `Sagatavoti ${totalChunks} chunki`;

        // 4) Izveido workerus
        createWorkerPool(numWorkers);

        // 5) Sūtam CSV, maxDistance => worker init
        for (let w of workers) {
          w.postMessage({
            type:'initCSV',
            csvPoints,
            maxDistance: MAX_DISTANCE
          });
        }

        // 6) Sāk chunkus
        for (let i=0; i<freeWorkers.length; i++) {
          scheduleChunk();
        }

      } catch (err) {
        console.error(err);
        errorDiv.textContent = "Kļūda: " + err.message;
      }
    });
  </script>

  <!--
    II. Worker SCRIPT (inline)
    Tas pats, kas iepriekš
  -->
  <script type="javascript/worker" id="worker-script">
    let csvPoints = [];
    let maxDistance = 0.2;

    onmessage = async (evt) => {
      const msg = evt.data;
      if (msg.type==='initCSV') {
        csvPoints = msg.csvPoints;
        maxDistance = msg.maxDistance || 0.2;
      }
      else if (msg.type==='processChunk') {
        const {buffer, chunkPoints, pointRecordLen, scale, offset} = msg;
        const dv = new DataView(buffer);
        let off=0;
        const updates = [];

        for (let i=0; i<chunkPoints; i++) {
          const Xint = dv.getInt32(off+0, true);
          const Yint = dv.getInt32(off+4, true);
          const Zint = dv.getInt32(off+8, true);
          off += pointRecordLen;

          const X = Xint*scale[0] + offset[0];
          const Y = Yint*scale[1] + offset[1];
          const Z = Zint*scale[2] + offset[2];

          // Naiva meklēšana CSV
          for (let c=0; c<csvPoints.length; c++) {
            const dx = csvPoints[c].x - X;
            const dy = csvPoints[c].y - Y;
            const dist2 = dx*dx + dy*dy;
            if (dist2 <= maxDistance*maxDistance) {
              updates.push({idx:c, dist:Math.sqrt(dist2), lasZ:Z});
            }
          }
        }
        postMessage({type:'chunkResult', payload:updates});
      }
      else if (msg.type==='noMoreChunks') {
        postMessage({type:'done'});
      }
    };
  </script>
</body>
</html>
