<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8">
  <title>LAS + CSV salīdzināšana ar k-d tree (kdbush)</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #results table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }
    #results th,
    #results td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    #error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>LAS un CSV salīdzināšana (ar k-d tree, kdbush)</h1>
  <p>
    Ielādējiet <strong>LAS</strong> failu (EPSG:3059, Point Data Format 0..3) un
    <strong>CSV</strong> failu (x,y,z). Tiks izveidots k-d tree, lai ātrāk meklētu tuvākos
    LAS punktus 20&nbsp;cm attālumā.
  </p>

  <p><strong>LAS fails:</strong></p>
  <input type="file" id="lasFile" accept=".las" />

  <p><strong>CSV fails:</strong></p>
  <input type="file" id="csvFile" accept=".csv,text/csv" />

  <br>
  <button id="processBtn">Sākt apstrādi</button>

  <div id="error"></div>
  <div id="results"></div>

  <!-- Papa Parse CSV parsēšanai -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- kdbush UMD fails (kdbush kļūst pieejams kā window.kdbush) -->
  <script src="https://cdn.jsdelivr.net/npm/kdbush@3.0.0/kdbush.umd.js"></script>

  <script>
    // ====== 1) Minimālais LAS parseris (atbalsta formātus 0..3, LAS 1.2/1.3) ======
    async function parseLAS(file) {
      const buffer = await file.arrayBuffer();
      const dataView = new DataView(buffer);

      // Pārbaudām "LASF" signatūru
      const signature = String.fromCharCode(
        dataView.getUint8(0),
        dataView.getUint8(1),
        dataView.getUint8(2),
        dataView.getUint8(3)
      );
      if (signature !== "LASF") {
        throw new Error("Failā netika atrasta 'LASF' signatūra. Vai tas tiešām ir .las fails?");
      }

      // Nolasām galvenes laukus
      const pointDataOffset = dataView.getUint32(96, true); // offset uz punktiem
      const numPoints = dataView.getUint32(107, true);      // punkti
      const scaleX = dataView.getFloat64(131, true);
      const scaleY = dataView.getFloat64(139, true);
      const scaleZ = dataView.getFloat64(147, true);
      const offsetX = dataView.getFloat64(155, true);
      const offsetY = dataView.getFloat64(163, true);
      const offsetZ = dataView.getFloat64(171, true);

      const pointDataFormat = dataView.getUint8(104);
      const pointRecordLen = dataView.getUint16(105, true);

      // Atbalstām tikai formātus 0..3
      if (![0,1,2,3].includes(pointDataFormat)) {
        throw new Error("Neparedzēts Point Data Format: " + pointDataFormat);
      }

      // Nolasām punktu datus
      const pointsArray = [];
      let offset = pointDataOffset;
      for (let i = 0; i < numPoints; i++) {
        const Xint = dataView.getInt32(offset + 0, true);
        const Yint = dataView.getInt32(offset + 4, true);
        const Zint = dataView.getInt32(offset + 8, true);

        const X = Xint * scaleX + offsetX;
        const Y = Yint * scaleY + offsetY;
        const Z = Zint * scaleZ + offsetZ;

        pointsArray.push({x: X, y: Y, z: Z});
        offset += pointRecordLen;
      }

      return pointsArray;
    }

    // ====== 2) CSV parsēšana ar Papa Parse ======
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const data = results.data;
              // Katram rindas objektam meklē x,y,z (ign. reģistru)
              const points = data.map(row => {
                const keys = {};
                for (let k of Object.keys(row)) {
                  keys[k.toLowerCase()] = row[k];
                }
                const X = parseFloat(keys['x']);
                const Y = parseFloat(keys['y']);
                const Z = parseFloat(keys['z']);
                return {x: X, y: Y, z: Z};
              }).filter(pt => !isNaN(pt.x) && !isNaN(pt.y) && !isNaN(pt.z));
              resolve(points);
            } catch (err) {
              reject(err);
            }
          },
          error: (err) => reject(err)
        });
      });
    }

    // ====== 3) kdbush – k-d tree jeb 2D meklēšanas struktūra ======
    // UMD fails izveido window.kdbush
    const KDBushClass = window.kdbush; // nav .default!

    let lasPoints = [];
    let csvPoints = [];
    let kdbIndex = null;

    function buildKDTree(points) {
      return new KDBushClass(
        points,
        p => p.x, // x accessor
        p => p.y, // y accessor
        64,
        Float32Array
      );
    }

    // 4) Meklē tuvāko LAS punktu 20cm rādiusā, izmantojot range() + manuālu distance
    function findNearestLASPointKD(csvPt, radius = 0.2) {
      const minX = csvPt.x - radius;
      const minY = csvPt.y - radius;
      const maxX = csvPt.x + radius;
      const maxY = csvPt.y + radius;

      // Atrodam kandidātu indeksus, kas ietilpst šajā taisnstūrī
      const candidateIndices = kdbIndex.range(minX, minY, maxX, maxY);

      let nearest = null;
      let minDist = Infinity;
      for (const idx of candidateIndices) {
        const lasPt = lasPoints[idx];
        const dx = lasPt.x - csvPt.x;
        const dy = lasPt.y - csvPt.y;
        const dist2D = Math.sqrt(dx*dx + dy*dy);
        if (dist2D < minDist && dist2D <= radius) {
          minDist = dist2D;
          nearest = lasPt;
        }
      }
      return nearest;
    }

    // ====== 5) Galvenais process ======
    const lasFileInput = document.getElementById('lasFile');
    const csvFileInput = document.getElementById('csvFile');
    const processBtn = document.getElementById('processBtn');
    const errorDiv = document.getElementById('error');
    const resultsDiv = document.getElementById('results');

    processBtn.addEventListener('click', async () => {
      // Notīrām iepriekšējos
      errorDiv.textContent = "";
      resultsDiv.innerHTML = "";

      if (!lasFileInput.files.length || !csvFileInput.files.length) {
        errorDiv.textContent = "Lūdzu, atlasiet gan LAS, gan CSV failu!";
        return;
      }

      try {
        resultsDiv.innerHTML = "Notiek ielāde un indeksa izveide, uzgaidiet...";

        // 1) Nolasa LAS failu → lasPoints
        lasPoints = await parseLAS(lasFileInput.files[0]);

        // 2) Izveido k-d tree
        kdbIndex = buildKDTree(lasPoints);

        // 3) Nolasa CSV failu → csvPoints
        csvPoints = await parseCSV(csvFileInput.files[0]);

        // 4) Katram CSV punktam meklē tuvāko LAS
        const rows = [];
        rows.push("<tr><th>CSV X</th><th>CSV Y</th><th>CSV Z</th><th>LAS Z</th><th>ΔZ (CSV-LAS)</th><th>2D attālums</th></tr>");

        for (const cpt of csvPoints) {
          const nearest = findNearestLASPointKD(cpt, 0.2);
          if (nearest) {
            const dz = cpt.z - nearest.z;
            const dist2D = Math.sqrt(
              (nearest.x - cpt.x) ** 2 +
              (nearest.y - cpt.y) ** 2
            );
            rows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>${nearest.z.toFixed(3)}</td>
                <td>${dz.toFixed(3)}</td>
                <td>${dist2D.toFixed(3)}</td>
              </tr>
            `);
          } else {
            rows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            `);
          }
        }

        resultsDiv.innerHTML = `
          <h3>Rezultāti</h3>
          <p>LAS punkti: ${lasPoints.length}, CSV punkti: ${csvPoints.length}</p>
          <table>${rows.join("")}</table>
        `;
      } catch (err) {
        console.error(err);
        errorDiv.textContent = err.message;
      }
    });
  </script>
</body>
</html>
