<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8">
  <title>LAS + CSV salīdzināšana ar k-d tree (kdbush)</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #results table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }
    #results th, #results td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
    #error {
      color: red;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>LAS un CSV salīdzināšana (ar k-d tree)</h1>
  <p>Ielādējiet <strong>LAS</strong> (EPSG:3059, Point Data Format 0..3, neliels piemērs) un <strong>CSV</strong> failu (x,y,z).</p>

  <p>LAS fails:</p>
  <input type="file" id="lasFile" accept=".las" />

  <p>CSV fails:</p>
  <input type="file" id="csvFile" accept=".csv,text/csv" />

  <br>
  <button id="processBtn">Sākt apstrādi</button>

  <div id="error"></div>
  <div id="results"></div>

  <!-- Papa Parse CSV parsēšanai -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- kdbush UMD builds (kdbush.umd.js) -->
  <script src="https://cdn.jsdelivr.net/npm/kdbush@3.0.0/kdbush.umd.js"></script>

  <script>
    // Lai varam lietot kdbush glabāto mainīgo
    // (CDN ielādē to kā window.KDBush UMD).
    const KDBush = window.KDBush;

    const lasInput = document.getElementById('lasFile');
    const csvInput = document.getElementById('csvFile');
    const processBtn = document.getElementById('processBtn');
    const errorDiv = document.getElementById('error');
    const resultsDiv = document.getElementById('results');

    let lasPoints = [];
    let csvPoints = [];
    let kdbIndex = null; // te glabāsim k-d tree (kdbush) indeksu

    // ----------------------------------------------------
    // 1) Minimālais LAS parseris (kā iepriekšējā piemērā)
    //    Atbalsta tikai "Point Data Format 0..3"
    // ----------------------------------------------------
    async function parseLAS(file) {
      const buffer = await file.arrayBuffer();
      const dataView = new DataView(buffer);

      // Pārbaude "LASF"
      const signature = String.fromCharCode(
        dataView.getUint8(0),
        dataView.getUint8(1),
        dataView.getUint8(2),
        dataView.getUint8(3)
      );
      if (signature !== "LASF") {
        throw new Error("Failā netika atrasta 'LASF' signatūra.");
      }

      // Galvenes lauki
      const versionMajor = dataView.getUint8(24, true);
      const versionMinor = dataView.getUint8(25, true);

      const pointDataOffset = dataView.getUint32(96, true); // [96..99]
      const numPoints = dataView.getUint32(107, true); // [107..110]
      const scaleX = dataView.getFloat64(131, true); // [131..138]
      const scaleY = dataView.getFloat64(139, true); // [139..146]
      const scaleZ = dataView.getFloat64(147, true); // [147..154]
      const offsetX = dataView.getFloat64(155, true); // [155..162]
      const offsetY = dataView.getFloat64(163, true); // [163..170]
      const offsetZ = dataView.getFloat64(171, true); // [171..178]

      const pointDataFormat = dataView.getUint8(104); // [104]
      const pointRecordLen = dataView.getUint16(105, true); // [105..106]

      if (![0,1,2,3].includes(pointDataFormat)) {
        throw new Error("Neparedzēts Point Data Format: " + pointDataFormat);
      }

      const pointsArray = [];
      let offset = pointDataOffset;
      for (let i = 0; i < numPoints; i++) {
        const Xint = dataView.getInt32(offset + 0, true);
        const Yint = dataView.getInt32(offset + 4, true);
        const Zint = dataView.getInt32(offset + 8, true);

        const X = Xint * scaleX + offsetX;
        const Y = Yint * scaleY + offsetY;
        const Z = Zint * scaleZ + offsetZ;

        pointsArray.push({x: X, y: Y, z: Z});
        offset += pointRecordLen;
      }

      return pointsArray;
    }

    // ----------------------------------------------------
    // 2) CSV lasīšana ar Papa Parse -> {x, y, z}
    // ----------------------------------------------------
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const data = results.data;
              const points = data.map(row => {
                const keys = {};
                for (let k of Object.keys(row)) {
                  keys[k.toLowerCase()] = row[k];
                }
                const X = parseFloat(keys['x']);
                const Y = parseFloat(keys['y']);
                const Z = parseFloat(keys['z']);
                return {x: X, y: Y, z: Z};
              }).filter(pt => !isNaN(pt.x) && !isNaN(pt.y) && !isNaN(pt.z));
              resolve(points);
            } catch (err) {
              reject(err);
            }
          },
          error: (err) => reject(err)
        });
      });
    }

    // ----------------------------------------------------
    // 3) Izveido k-d tree (kdbush)
    // ----------------------------------------------------
    function buildKDTree(points) {
      // kdbush gaida masīvu, un jānorāda, kā izvilkt x un y
      // const index = new KDBush(points, getX, getY, nodeSize=64, ArrayType=Float32Array);
      return new KDBush(
        points,
        p => p.x, // x accessor
        p => p.y, // y accessor
        64,       // nodeSize (lielāka vērtība -> mazāks koka dziļums)
        Float32Array
      );
    }

    // ----------------------------------------------------
    // 4) Meklē tuvāko LAS punktu 20cm rādiusā, izmantojot k-d tree
    //    - izmanto kdbush .range() lai atrastu kandidātus
    //    - no kandidātiem izvēlas vistuvāko 2D attālumā
    // ----------------------------------------------------
    function findNearestLASPointKD(csvPt, radius = 0.2) {
      // Taisnstūra meklēšana:
      const minX = csvPt.x - radius;
      const minY = csvPt.y - radius;
      const maxX = csvPt.x + radius;
      const maxY = csvPt.y + radius;

      // range() atgriež to punktu indeksus, kas atrodas šajā X/Y robežā
      const candidateIndices = kdbIndex.range(minX, minY, maxX, maxY);

      let nearest = null;
      let minDist = Infinity;
      for (const idx of candidateIndices) {
        const lasPt = lasPoints[idx]; // jo index.range() atgriež masīva indexus
        const dx = lasPt.x - csvPt.x;
        const dy = lasPt.y - csvPt.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDist && dist <= radius) {
          minDist = dist;
          nearest = lasPt;
        }
      }
      return nearest;
    }

    // ----------------------------------------------------
    // 5) Pogas notikums
    // ----------------------------------------------------
    processBtn.addEventListener('click', async () => {
      errorDiv.textContent = "";
      resultsDiv.innerHTML = "";

      if (!lasInput.files.length || !csvInput.files.length) {
        errorDiv.textContent = "Lūdzu, atlasiet gan LAS, gan CSV failu!";
        return;
      }

      try {
        resultsDiv.innerHTML = "Notiek ielāde un indeksa izveide, uzgaidiet...";
        
        // 1. Parse LAS
        lasPoints = await parseLAS(lasInput.files[0]);

        // 2. Izveido k-d tree index
        //    (Padomājiet par laiku un atmiņu, ja lasPoints ir ļoti liels.)
        kdbIndex = buildKDTree(lasPoints);

        // 3. Parse CSV
        csvPoints = await parseCSV(csvInput.files[0]);

        // Tagad varam meklēt daudz ātrāk
        const rows = [];
        rows.push("<tr><th>CSV X</th><th>CSV Y</th><th>CSV Z</th><th>LAS Z</th><th>ΔZ (CSV-LAS)</th><th>2D dist</th></tr>");

        for (const cpt of csvPoints) {
          const nearest = findNearestLASPointKD(cpt, 0.2);
          if (nearest) {
            const dz = cpt.z - nearest.z;
            const dist2d = Math.sqrt((nearest.x - cpt.x)**2 + (nearest.y - cpt.y)**2);
            rows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>${nearest.z.toFixed(3)}</td>
                <td>${dz.toFixed(3)}</td>
                <td>${dist2d.toFixed(3)}</td>
              </tr>
            `);
          } else {
            rows.push(`
              <tr>
                <td>${cpt.x.toFixed(3)}</td>
                <td>${cpt.y.toFixed(3)}</td>
                <td>${cpt.z.toFixed(3)}</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            `);
          }
        }

        resultsDiv.innerHTML = `
          <h3>Rezultāti</h3>
          <p>LAS punkti: ${lasPoints.length}, CSV punkti: ${csvPoints.length}</p>
          <table>${rows.join("")}</table>
        `;
      } catch (err) {
        console.error(err);
        errorDiv.textContent = err.message;
      }
    });
  </script>
</body>
</html>
