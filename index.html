<!DOCTYPE html>
<html lang="lv">
<head>
  <meta charset="UTF-8" />
  <title>LAS un CSV Z atšķirību salīdzināšana (EPSG:3059)</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #dropZone {
      width: 100%;
      height: 60px;
      border: 2px dashed #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      color: #666;
      cursor: pointer;
    }
    #results table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
    }
    #results th, #results td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>LAS un CSV salīdzināšana (EPSG:3059)</h1>

  <p>1) Ielādējiet LAS failu (EPSG:3059)</p>
  <input type="file" id="lasFile" accept=".las,.laz" />

  <p>2) Ielādējiet CSV failu (kolonnas x,y,z vai X,Y,Z, EPSG:3059)</p>
  <input type="file" id="csvFile" accept=".csv,text/csv" />

  <br><br>
  <button id="processBtn">Sākt apstrādi</button>
  
  <div id="results"></div>

  <!-- Papa Parse bibliotēka CSV parsēšanai -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  
  <!-- laslaz.js bibliotēka no Potree CDN. -->
  <!-- Brīdinājums: starp versijām var būt atšķirības. -->
  <script src="https://cdn.potree.org/potree/2.1/libs/laslaz/laslaz.js"></script>

  <script>
    const lasInput = document.getElementById('lasFile');
    const csvInput = document.getElementById('csvFile');
    const processBtn = document.getElementById('processBtn');
    const resultsDiv = document.getElementById('results');

    let lasPoints = [];  // Te saglabāsim LAS punktus [ {x, y, z}, ... ]
    let csvPoints = [];  // Te saglabāsim CSV punktus [ {x, y, z}, ... ]

    // ==============================================================
    // 1) LAS faila ielāde un parsēšana, izmantojot LASLAZ (Potree)
    // ==============================================================
    function parseLAS(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const buffer = e.target.result;
          LASModule.onRuntimeInitialized = () => {
            try {
              const las = new LASModule.LASFile(new Uint8Array(buffer));
              las.open();

              // Šajā piemērā izlasīsim *visus* punktus.
              // Lieliem failiem tas var būt ļoti lēns un prasīt daudz atmiņas.
              // Reālās sistēmās vēlams izmantot strīmošanu vai telpiskos indeksus.
              const totalPoints = las.header.pointsCount;
              const reader = new LASModule.LASDecoder(las, las.header);

              const pointsArray = [];
              for (let i = 0; i < totalPoints; i++) {
                const p = reader.getPoint(i);
                // p.x, p.y, p.z - jau atgriezti "reālajās" vienībās?
                // Dažādām laslaz.js versijām formāti var nedaudz atšķirties,
                // iespējams, jālieto scale no las.header.scale, offset no las.header.offset.
                
                const scale = las.header.scale;
                const offset = las.header.offset;
                const X = p.x * scale[0] + offset[0];
                const Y = p.y * scale[1] + offset[1];
                const Z = p.z * scale[2] + offset[2];

                pointsArray.push({x: X, y: Y, z: Z});
              }
              lasPoints = pointsArray;

              las.close();
              las = null;
              resolve();
            } catch (err) {
              reject(err);
            }
          }
        };
        reader.onerror = err => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    // ==============================================================
    // 2) CSV faila ielāde un parsēšana ar Papa Parse
    // ==============================================================
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const data = results.data;
              // Mēģinām atrast kolonnas x,y,z vai X,Y,Z (ignorējot reģistru)
              // un konvertējam iekš [ {x, y, z}, ... ]
              csvPoints = data.map(row => {
                // Kolonnu nosaukumi var būt x/X, y/Y, z/Z
                // Pielietosim mazos burtus un tad ielasīsim.
                const keys = Object.keys(row).reduce((acc, k) => {
                  acc[k.toLowerCase()] = row[k];
                  return acc;
                }, {});

                const X = parseFloat(keys['x']);
                const Y = parseFloat(keys['y']);
                const Z = parseFloat(keys['z']);
                return {x: X, y: Y, z: Z};
              }).filter(pt => !isNaN(pt.x) && !isNaN(pt.y) && !isNaN(pt.z));

              resolve();
            } catch (err) {
              reject(err);
            }
          },
          error: (err) => {
            reject(err);
          }
        });
      });
    }

    // ==============================================================
    // 3) Funkcija atrod tuvāko LAS punktu 20 cm (0.2m) rādiusā
    //    (Naiva implementācija, kas pārbauda visus punktus.)
    // ==============================================================
    function findNearestLASPoint(csvPt, maxDistance = 0.2) {
      let nearestPoint = null;
      let minDist = Infinity;

      for (const lasPt of lasPoints) {
        const dx = lasPt.x - csvPt.x;
        const dy = lasPt.y - csvPt.y;
        const dist2D = Math.sqrt(dx*dx + dy*dy);
        if (dist2D <= maxDistance && dist2D < minDist) {
          minDist = dist2D;
          nearestPoint = lasPt;
        }
      }
      return nearestPoint;
    }

    // ==============================================================
    // 4) Apstrādes poga
    // ==============================================================
    processBtn.addEventListener('click', async () => {
      if (!lasInput.files.length || !csvInput.files.length) {
        alert("Lūdzu, atlasiet gan LAS, gan CSV failu!");
        return;
      }

      resultsDiv.innerHTML = "<p>Notiek apstrāde, lūdzu uzgaidiet...</p>";

      try {
        // 1) Ielasam LAS
        await parseLAS(lasInput.files[0]);
        // 2) Ielasam CSV
        await parseCSV(csvInput.files[0]);
        
        // 3) Salīdzinām punktus
        const tableRows = [];
        tableRows.push("<tr><th>CSV X</th><th>CSV Y</th><th>CSV Z</th><th>LAS Z</th><th>ΔZ (CSV - LAS)</th><th>2D attālums</th></tr>");

        for (const cPt of csvPoints) {
          const nearest = findNearestLASPoint(cPt, 0.2);
          if (nearest) {
            const dz = cPt.z - nearest.z;
            const dist2D = Math.sqrt(Math.pow(nearest.x - cPt.x, 2) + Math.pow(nearest.y - cPt.y, 2));
            tableRows.push(
              `<tr>
                 <td>${cPt.x.toFixed(3)}</td>
                 <td>${cPt.y.toFixed(3)}</td>
                 <td>${cPt.z.toFixed(3)}</td>
                 <td>${nearest.z.toFixed(3)}</td>
                 <td>${dz.toFixed(3)}</td>
                 <td>${dist2D.toFixed(3)}</td>
               </tr>`
            );
          } else {
            tableRows.push(
              `<tr>
                 <td>${cPt.x.toFixed(3)}</td>
                 <td>${cPt.y.toFixed(3)}</td>
                 <td>${cPt.z.toFixed(3)}</td>
                 <td>-</td>
                 <td>-</td>
                 <td>-</td>
               </tr>`
            );
          }
        }

        const tableHtml = `<table>${tableRows.join("\n")}</table>`;
        resultsDiv.innerHTML = `<h3>Rezultāti</h3>${tableHtml}`;

      } catch (err) {
        console.error(err);
        resultsDiv.innerHTML = `<p>Kļūda apstrādē: ${err.message}</p>`;
      }
    });
  </script>
</body>
</html>
